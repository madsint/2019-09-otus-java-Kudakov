### Способ измерения

 Для тестирования использовалась виртуальная машина с 3ГБ памяти и 2 ядрами. Память, выделенная на heap: 1ГБ (-Xms1024m -Xmx1024m)

Запуск тестов осуществляется путем вызова метода run() из класса Benchmark. В методе реализовано заполнение коллекции строковыми объектами в бесконечном цикле порциями по 100000 объектов с последующим удалением половины от указанного количества. Между итерациями установлена пауза 1000 мс.  

Точка входа - класс Main . В этом же классе организована подписка на GarbageCollectorMXBean с выводом основных показателей на консоль.

Помимо этого, в параметрах запуска указан вывод краткого лога -Xlog:gc на консоль. Плюс вывод детального лога в файл.
Вывод логов и текстовая информация с консоли сохранены в папке logs.

Детальный лог для каждого из рассматриваемых сборщиков мусора обработан в онлайн анализаторе логов [gceasy.io](gceasy.io).

Рассмотрим результаты.

### SerialGC

_1_ Throughput : **85.737%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	1 sec 454 ms|
|Max Pause GC Time| 	1 sec 990 ms|

Несмотря на примитивность serial GC показал приемлемые результаты.  

### ParallelGC


_1_ Throughput : **87.126%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	1 sec 540 ms|
|Max Pause GC Time| 	4 sec 360 ms|

Parallel GC не смог значительно опередить своего предшественника. Вероятно это связано с тем, что высокие накладные расходы снизили возможные преимущества параллельного выполнения операций.

Параллельное выполнение оказалось не слишком эффективно в условиях: 

1) небольшого количества доступной памяти, что, учитывая относительно большой размер коллекций, не дало эффективно использовать механизм параллельного доступа к памяти (TLAB);

2) всего двух доступных физических ядер. 

### G1GC


_1_ Throughput : **93.832%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	253 ms|
|Max Pause GC Time| 	3 sec 120 ms|

Победителем и по пропускной способности и по задержкам оказался новый сборщик мусора G1. Это можно связать с более эффективной работой с памятью в рассматриваемых условиях по сравнению с parallel GC.

### Выводы

Основным выводом из проведенной работы можно считать то, что производительность сборщиков мусора зависит от конкретного аппаратного и программного окружения и особенностей реализации приложения. Для выбора конкретного сборщика, требуется помимо понимания различий типов сборщиков, изучать влияние разных факторов на их работу, проводить замеры и внимательно отслеживать показатели производительности.   